<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>Kick-off football game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100% }
    </style>
</head>

<body>

    <div id="message"></div>

    <script src="js/three.min.js"></script>
    <script src="js/physi.js"></script>
    <script src="js/controls/OrbitControls.js"></script>
    <script src="js/socket.io.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/KeyboardState.js"></script>

    <script type="text/javascript">
            /* Local */
        // Physijs.scripts.worker = './js/physijs_worker.js';
        // Physijs.scripts.ammo = 'ammo.js';
            /* Flask */
        Physijs.scripts.worker = '/js/physijs_worker.js';
        Physijs.scripts.ammo = '/js/ammo.js';


            /*** Socket.IO ***/
        var socket = io();


            /*** Scene ***/
        var scene = new Physijs.Scene();


            /*** Renderer ***/
        var renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0xdddddd);
        renderer.setSize(window.innerWidth, window.innerHeight - 23);
        renderer.shadowMap.enabled = true;
        renderer.shadowMapSoft = true;
        document.body.appendChild(renderer.domElement);



                /**************\
                |*   Camera   *|
                \**************/

            /*** Kicker ***/
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight - 23), .1, 1000);

        camera.position.set(30, 30, 30);
        camera.lookAt(new THREE.Vector3(0, 0, 0)); // for starting cam point

        // orbit controls for the cam
        var controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.maxPolarAngle = Math.PI * 0.5;
        controls.target.set(0, 0, 0); // for orbit cam point
        controls.minDistance = 30;
        controls.maxDistance = 100;


            /*** Goalie ***/
        // var camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight - 23), .1, 1000);
        //
        // camera.position.set(0, 25, -70);
        // camera.lookAt(new THREE.Vector3(0, 10, -30)) // for starting cam point
        //
        // //  orbit controls for the cam
        // var controls = new THREE.OrbitControls(camera, renderer.domElement);
        // controls.maxPolarAngle = Math.PI * 0.5;
        // controls.target.set(0, 10, -30); // for orbit cam point
        // controls.minDistance = 30;
        // controls.maxDistance = 60;



                /**************\
                |*   Lights   *|
                \**************/

        var spotLight = new THREE.SpotLight(0xffffff, 3);
        spotLight.castShadow = true;
        spotLight.position.set(15, 50, 30);
        scene.add(spotLight);
        spotLight.shadow.camera.near = 1;



                /*************\
                |*   Scene   *|
                \*************/

            /*** Field ***/
        var plane = new Physijs.BoxMesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshLambertMaterial({ color: 0xffffff }),
            0
        );

        plane.rotation.x = -.5 * Math.PI;
        plane.receiveShadow = true;
        scene.add(plane);

        spotLight.target = plane;


            /*** Goal ***/
        var postGeometry = new THREE.CylinderGeometry(.5, .5, 20);
        var postMaterial = new THREE.MeshLambertMaterial({ color: 0x7a0c0c });
        var post1 = new Physijs.CylinderMesh(postGeometry, postMaterial, 0);
        var post2 = new Physijs.CylinderMesh(postGeometry, postMaterial, 0);
        var crossbar = new Physijs.CylinderMesh(postGeometry, postMaterial, 0);

        var goalHeight = 12;
        post1.position.set(-10, goalHeight - 10, -40);
        post2.position.set(10, goalHeight - 10, -40);
        crossbar.position.set(0, goalHeight, -40);
        crossbar.rotation.z = -.5 * Math.PI;
        scene.add(post1);
        scene.add(post2);
        scene.add(crossbar);


            /*** Trigger ***/
        var trigger = new THREE.Mesh(
            new THREE.CubeGeometry(18, 20, 0.1),
            new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true })
        );
        trigger.position.set(0, 1, -40);
        scene.add(trigger);

        var collidableMeshList = [];
        collidableMeshList.push(trigger);

        var stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.bottom = '0px';
        stats.domElement.style.zIndex = 100;



                /************\
                |*   Ball   *|
                \************/

            /*** Object ***/
        var ball = new Physijs.SphereMesh(
            new THREE.SphereGeometry(2, 12, 12),
            new THREE.MeshLambertMaterial({ color: 0x7a0c0c })
        );
        ball.position.set(0, 5.5, 0);
        ball.castShadow = true;
        scene.add(ball);


            /*** Controls ***/
        var clock = new THREE.Clock();
        var keyboard = new KeyboardState();

        document.addEventListener('keydown', function(event) {
            keyboard.update();

            var moveDistance = 10 * clock.getDelta();

            if (keyboard.pressed("A")) {
                ball.translateX(-moveDistance);
                ball.__dirtyPosition = true;
            }

            if (keyboard.pressed("D")) {
                ball.translateX(moveDistance);
                ball.__dirtyPosition = true;
            }

            if (keyboard.pressed("W")) {
                ball.translateZ(-moveDistance);
                ball.__dirtyPosition = true;
            }

            if (keyboard.pressed("S")) {
                ball.translateZ(moveDistance);
                ball.__dirtyPosition = true;
            }

            controls.update();
            stats.update();

        }, false);



                /**************\
                |*   Goalie   *|
                \**************/

            /*** Object ***/
        var goalie = new Physijs.BoxMesh(
            new THREE.BoxGeometry(5, 7, 3),
            new THREE.MeshBasicMaterial({ color: 0x307460 })
        );
        goalie.position.set(0, 4, -35);
        goalie.castShadow = true;
        scene.add(goalie);


            /*** Socket ***/
        function sendGoalie() {
            var pos = goalie.position;
            var rot = goalie.rotation;
            var lv = goalie.getLinearVelocity();
            var av = goalie.getAngularVelocity();
            socket.emit('goalie',
                {'pos': pos,
                'rot': rot,
                'lv': lv,
                'av': av}
            );
        }

        socket.on('goalie', function(json) {
            goalie.position.set(json.pos.x, json.pos.y, json.pos.z);
            goalie.__dirtyPosition = true;
            goalie.rotation.set(json.rot.x, json.rot.y, json.rot.z);
            goalie.__dirtyPositionRotation = true;
            goalie.setLinearVelocity(json.lv);
            goalie.setAngularVelocity(json.av);
        });


            /*** Controls ***/
        var goalieMoving = false;
        document.addEventListener('keydown', function(event) {
            goalieBlocked = false;
            goalieSpeed = 100;
            var goalieLV = goalie.getLinearVelocity()

            if (event.key == "i") {
                goalie.setLinearVelocity(
                    goalieLV.add({ x: -goalieLV.x, y: goalieSpeed / 2, z: 0 })
                );
                sendGoalie();

            } else if (!goalieMoving) {
                switch (event.key) {

                    case "j":
                        goalie.setLinearVelocity(
                            goalieLV.add({ x: goalieSpeed, y: 0, z: 0 })
                        );
                        sendGoalie();
                        goalieMoving = true;
                        break;

                    case "l":
                        goalie.setLinearVelocity(
                            goalieLV.add({ x: -goalieSpeed, y: 0, z: 0 })
                        );
                        sendGoalie();
                        goalieMoving = true;
                        break;
                }
            }
        }, false);
        document.addEventListener('keyup', function(event) {
            if (goalieMoving) {
                var goalieLV = goalie.getLinearVelocity()

                switch (event.key) {
                    case "j":
                    case "l":
                        goalie.setLinearVelocity(goalieLV.add({ x: -goalieLV.x, y: 0, z: 0 }));
                        sendGoalie();
                        goalieMoving = false;
                        break;
                }
            }
        }, false);

        var goalieBlocked = false;



                /*******************\
                |*   Visual Help   *|
                \*******************/

            /*** Axis ***/
        var axis = new THREE.AxisHelper(10);
        axis.position.set(0, .25, 0);
        scene.add(axis);


            /*** Grid ***/
        var grid = new THREE.GridHelper(50, 10);
        scene.add(grid);



                /*****************\
                |*   Rendering   *|
                \*****************/

        function clearText() { document.getElementById('message').innerHTML = '....'; }
        function appendText(txt) { document.getElementById('message').innerHTML += txt; }

        var render = function() {

            requestAnimationFrame(render);


                /*** Ball ***/
            clearText();

            var originPoint = ball.position.clone();
            for (var vertexIndex = 0; vertexIndex < ball.geometry.vertices.length; vertexIndex++) {
                var localVertex = ball.geometry.vertices[vertexIndex].clone();
                var globalVertex = localVertex.applyMatrix4(ball.matrix);
                var directionVector = globalVertex.sub(ball.position);

                var ray = new THREE.Raycaster(originPoint, directionVector.clone().normalize());
                var collisionResults = ray.intersectObjects(collidableMeshList);
                if (collisionResults.length > 0 && collisionResults[0].distance < directionVector.length())
                    appendText(" GOAL! ");
            }


                /*** Goalie ***/
            var goalieLV = goalie.getLinearVelocity()
            if (goalie.position.y > goalHeight && !goalieBlocked) {
                goalie.setLinearVelocity(
                    goalieLV.add({ x: 0, y: -goalieLV.y * 1.2, z: 0 })
                );
                goalieBlocked = true;
            }
            if (goalie.position.x > 10 && goalieLV.x > 1 ||
                goalie.position.x < -10 && goalieLV.x < -1) {
                goalie.setLinearVelocity(
                    goalieLV.add({ x: -goalieLV.x, y: 0, z: 0 })
                );
            }


            scene.simulate();
            renderer.render(scene, camera);
        }

        render();
    </script>
</body>

</html>
